# ObjectPool
一个内存池模型demo，通过重载new和delete实现完全解耦的对象池管理，只需要继承一个基类便能使用该内存池模式。

----------------------------------------------------------------------------------------------------

该内存池模型仅需要继承一个模板基类RSHelper（可参考main.cpp），第一个模板参数指定内存池中的对象类型，第二个模板参数为int型指定对象池中的最大对象数，内存池中的所有对象被安排在一大块连续内存中，并用一个指针链表指向这块内存中的每个对象的起始地址，每次需要时便从该链表中取一个指针并在指针所指向的内存块上构造对象，如果链表为空，即对象池用完了，则用malloc分配内存块。
回收时采用同样的逻辑，不过会先判断地址是否在那块连续内存块中，不在则调用free，在的话就放回链表。
链表的操作加了锁，故是线程安全的。

继承了RSHelper的类new时会自动在内存池中构造，不够时也会自动调用malloc，delete时也能自动回收或者释放，实现了解耦。

----------------------------------------------------------------------------------------------------

原先的链表采用的stl的froward_list，并以mutex进行加锁保证同步。现改为自定义的无锁链表，用原子操作保证一致性。还自定义了DeleteGuard来保证链表节点（都是堆对象）的释放。
